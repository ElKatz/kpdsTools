function [pp] = convert_pds4_to_pp(PDS)
%   [pp] = convert_pds4_to_pp(PDS)
% convert a PDS (generated by PLDAPS 4) to a struct named 'pp'.
%
% INPUT:
%   PDS - standard PLDAPS version 4 PDS struct
% OUTPUT:
%   pp  - struct version of the pds (pp) with necessary
%          fields for later analysis.
%
% lnk. based on ajl's twagConvertFromCell
% unlike ajl's version, I take ALL trials, not just good.

%%

nTrials = numel(PDS.data);

% do a quick check for missing fields. These will happen due to pauses:
for ii = 1:length(PDS.data)
    if ~isfield(PDS.data{ii}, 'targRchosen');           PDS.data{ii}.targRchosen = nan;             end
    if ~isfield(PDS.data{ii}, 'correct');               PDS.data{ii}.correct = nan;                 end
    if ~isfield(PDS.data{ii}.theseGabs, 'targCorrect'); PDS.data{ii}.theseGabs.targCorrect = nan;   end
end

goodtrial = cell2mat(cellfun(@(x) x.pldaps.goodtrial, PDS.data, 'UniformOutput', false));
goodtrial(isnan(goodtrial)) = 0;

nPulses         = cellfun(@(x) x.theseGabs.nPulses, PDS.data, 'UniformOutput', false);
cohmat          = cellfun(@(x) x.theseGabs.cohmat, PDS.data, 'UniformOutput', false);
% gabCoh          = cellfun(@(x) x.theseGabs.gabCoh, PDS.data, 'UniformOutput', false); % # gabors pulsing. need this for prop. gabors coherence
sumCoh          = cellfun(@(x) x.theseGabs.sumCoh, PDS.data, 'UniformOutput', false);
stimDistNum     = cellfun(@(x) x.theseGabs.stimDistNum, PDS.data, 'UniformOutput', false);
stimDistName    = cellfun(@(x) x.theseGabs.stimDistName, PDS.data, 'UniformOutput', false);
targCorrect     = cellfun(@(x) x.theseGabs.targCorrect, PDS.data, 'UniformOutput', false);
correct         = cellfun(@(x) x.correct, PDS.data, 'UniformOutput', false);
targRchosen     = cellfun(@(x) x.targRchosen, PDS.data, 'UniformOutput', false);
unique_number               = cellfun(@(x) x.unique_number, PDS.data, 'UniformOutput', false);

% cell2mat everything. store in 'pp':
pp.goodTrial    = logical(goodtrial)';
pp.nPulses      = cell2mat(nPulses)';
pp.cohmat       = cell2mat(cohmat)';
% pp.gabCoh       = cell2mat(gabCoh)';
pp.sumCoh       = cell2mat(sumCoh)';
pp.stimDistNum  = cell2mat(stimDistNum)';
pp.targCorrect  = cell2mat(targCorrect)';
pp.correct      = cell2mat(correct)';
pp.targRchosen  = cell2mat(targRchosen)';
pp.stimDistName = stimDistName';

unique_number = cell2mat(unique_number);
unique_number = reshape(unique_number, 6, length(PDS.data));
pp.unique_number = unique_number';



pp.initialParametersMerged =  PDS.initialParametersMerged;

if isfield(PDS.data{1}.theseGabs, 'gabCoh')
    gabCoh          = cellfun(@(x) x.theseGabs.gabCoh, PDS.data, 'UniformOutput', false); % # gabors pulsing. need this for prop. gabors coherence
    pp.gabCoh       = cell2mat(gabCoh)';
end

% save frozen trial index, if it exists
if isfield(PDS.data{1}.stimulus, 'frozentrials')
    frozenTrials    = cellfun(@(x) x.stimulus.frozentrials, PDS.data, 'UniformOutput', false);
    pp.frozenTrials = cell2mat(frozenTrials)';
else
    pp.frozenTrials = nan(nTrials, 1);
end

%% eye position:

for iT = 1:nTrials
    
    t = PDS.data{iT}.eyelink.samples(1,:);
    x = PDS.data{iT}.eyelink.samples(4,:);
    y = PDS.data{iT}.eyelink.samples(5,:);
    
    % figure out the synch between these times and pp.timing...
    % then segment out the range the saccade should take place in
    % send to saccadeTools
    % get goodies.
    % then do the same for non-pds_v4
end

%% timing

for iT = 1:nTrials
    
    states = PDS.initialParametersMerged.stimulus.states;
    
    % start:
    pp.timing(iT).start = 0;
    % fpon:
    try
        idx = states.FPON;
        pp.timing(iT).fpon = PDS.data{iT}.stimulus.statesStartTime(idx);
    catch
        pp.timing(iT).fpon = nan;
    end
    % fphold:
    try
        idx = states.FPHOLD;
        pp.timing(iT).fphold = PDS.data{iT}.stimulus.statesStartTime(idx);
    catch
        pp.timing(iT).fphold = nan;
    end
    % targeton:
    try
        idx = states.TARGETON;
        pp.timing(iT).targeton = PDS.data{iT}.stimulus.statesStartTime(idx);
    catch
        pp.timing(iT).targeton = nan;
    end
    % motionon:
    try
        idx = states.MOTIONON;
        pp.timing(iT).motionon = PDS.data{iT}.stimulus.statesStartTime(idx);
    catch
        pp.timing(iT).motionon = nan;
    end
    % fpoff:
    try
        idx = states.FPOFF;
        pp.timing(iT).fpoff = PDS.data{iT}.stimulus.statesStartTime(idx);
    catch
        pp.timing(iT).fpoff = nan;
    end
    % choosetarget:
    try
        idx = states.CHOOSETARGET;
        pp.timing(iT).choosetarget = PDS.data{iT}.stimulus.statesStartTime(idx);
    catch
        pp.timing(iT).choosetarget = nan;
    end
    % breakfix:
    try
        idx = states.BREAKFIX;
        pp.timing(iT).breakfix = PDS.data{iT}.stimulus.statesStartTime(idx);
    catch
        pp.timing(iT).breakfix = nan;
    end
    % trialcomplete:
    try
        idx = states.TRIALCOMPLETE;
        pp.timing(iT).trialcomplete = PDS.data{iT}.stimulus.statesStartTime(idx);
    catch
        pp.timing(iT).trialcomplete = nan;
    end
    % duration of target hold: (this is a single value that's set at first)
    % ------------------------
    pp.timing(iT).durationtargethold = PDS.initialParametersMerged.stimulus.durationtarghold;
    
end

%% visualize timing
visualize_timing = false;
if visualize_timing
    figure
    flds =    { ...
        'start', ...
        'fpon', ...
        'fphold', ...
        'targeton', ...
        'motionon', ...
        'fpoff', ...
        'choosetarget', ...
        'trialcomplete'};
    
    for iF = 1:numel(flds)
        subplot(numel(flds)+1, 1, iF);
        hold on
        title(flds{iF});
        times = [pp.timing.(flds{iF})];
        histogram(times(pp.goodTrial), 50);
        xlim([0 5])
    end
    % reaction time:
    subplot(numel(flds)+1, 1, iF+1);
    hold on
    title('REACTION TIME');
    rt = [pp.timing.choosetarget] - [pp.timing.fpoff];
    histogram(rt(pp.goodTrial), 50);
    xlim([0 1])
end







